package compiler;

import java_cup.runtime.*;
import org.apache.log4j.*;
import ast.*;



parser code {:
	boolean errorDetected = false;
	Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}
// preko yylex  
scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, RETURN, VOID, LBRACKET, RBRACKET;
terminal SEMICOLN,EQUAL, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, CONST, NEW;
terminal PRINT,READ;

terminal ADD, SUB, MUL, DIV, MOD, INC, DECR;
terminal EQUALS, NEQUALS, GRT, GRTEQUAL, LESS, LESSEQUAL, AND, OR;

terminal IF, ELSE, SWITCH, CASE;
terminal DO, WHILE, BREAK, CONTINUE;

//a?b:c;
terminal DDOTS,QMARK;

terminal String IDENT;
terminal Integer NUM;
terminal Object BOOLEAN;
terminal Character CHAR;

non terminal Program Program;
non terminal ConstVarDeclRepeat ConstVarDeclRepeat;
non terminal MethodDeclRepeat MethodDeclRepeat;
non terminal ConstVarDecl ConstVarDecl;
non terminal ConstDecl ConstDecl;
nonterminal VarDecl VarDecl;
non terminal Type Type;
non terminal ConstValue ConstValue;
non terminal ConstDeclRepeat ConstDeclRepeat;
non terminal OptArray OptArray;
non terminal VarDeclRepeat VarDeclRepeat;
non terminal MethodDecl MethodDecl;
non terminal MethodType MethodType;
non terminal ElseStatementOptional ElseStatementOptional;
non terminal FormParsOptional FormParsOptional;
nonterminal FormPars FormPars;
non terminal FormParDecl FormParDecl;
non terminal ArrayDeclOptional ArrayDeclOptional;
non terminal FormParsRepeat FormParsRepeat;
non terminal StatementRepeat StatementRepeat;
non terminal Statement Statement;
non terminal PrintWidthOptional PrintWidthOptional;
non terminal CaseRepeat CaseRepeat;
non terminal DesignatorStatement DesignatorStatement;
non terminal Assignop Assignop;
non terminal ActParsOptional ActParsOptional;
non terminal ActPars ActPars;
non terminal ActParsExprRepeat ActParsExprRepeat;
non terminal Condition Condition;
non terminal CondTermOrRepeat CondTermOrRepeat;
non terminal CondTerm CondTerm;
non terminal CondFactorAndRepeat CondFactorAndRepeat;
non terminal CondFact CondFact;
non terminal RelopExprOptional RelopExprOptional;
non terminal Relop Relop;
non terminal ExprOptional ExprOptional;
non terminal Expr Expr;
non terminal MinusOptional MinusOptional;
non terminal TermAddopRepeat TermAddopRepeat;
non terminal Term Term;
non terminal FactorMulopRepeat FactorMulopRepeat;
non terminal Factor Factor;
non terminal Addop Addop;
non terminal Mulop Mulop;
non terminal Designator Designator;

precedence left ELSE;

//terminali allcaps
//zagrade na desnoj strani su ime klase u ast



Program ::= (Program) PROGRAM IDENT:programName ConstVarDeclRepeat:C1 LBRACE MethodDeclRepeat:M2 RBRACE {: RESULT=new Program(programName, C1, M2); RESULT.setLine(programNameleft); :};

ConstVarDeclRepeat ::= (ConstVarDeclRepeatExists) ConstVarDeclRepeat:C1 ConstVarDecl:C2 {: RESULT=new ConstVarDeclRepeatExists(C1, C2); RESULT.setLine(C1left); :}
                     |
                     (ConstVarDeclRepeatEmpty) {: RESULT=new ConstVarDeclRepeatEmpty(); :} /* empty */
                     ;

ConstVarDecl ::= ConstDecl:C1 {: RESULT=new ConstVarDeclDerived1(C1); RESULT.setLine(C1left); :} | VarDecl:V1 {: RESULT=new ConstVarDeclDerived2(V1); RESULT.setLine(V1left); :};
ConstDecl ::= CONST Type:T1 IDENT:I2 EQUAL ConstValue:C3 ConstDeclRepeat:C4 SEMICOLN {: RESULT=new ConstDeclDerived1(T1, I2, C3, C4); RESULT.setLine(T1left); :};
ConstValue ::= NUM:N1 {: RESULT=new ConstValueDerived1(N1); RESULT.setLine(N1left); :} | CHAR:C1 {: RESULT=new ConstValueDerived2(C1); RESULT.setLine(C1left); :} | BOOLEAN {: RESULT=new ConstValueDerived3(); :};
ConstDeclRepeat ::= ConstDeclRepeat:C1 COMMA IDENT:I2 EQUAL ConstValue:C3 {: RESULT=new ConstDeclRepeatDerived1(C1, I2, C3); RESULT.setLine(C1left); :} | {: RESULT=new ConstDeclRepeatDerived2(); :} /* empty */;

Type ::= IDENT:I1 {: RESULT=new TypeDerived1(I1); RESULT.setLine(I1left); :};

VarDecl ::= Type:T1 IDENT:I2 OptArray:O3 VarDeclRepeat:V4 SEMICOLN {: RESULT=new VarDeclDerived1(T1, I2, O3, V4); RESULT.setLine(T1left); :};
VarDeclRepeat ::= VarDeclRepeat:V1 COMMA IDENT:I2 OptArray:O3 {: RESULT=new VarDeclRepeatDerived1(V1, I2, O3); RESULT.setLine(V1left); :} | {: RESULT=new VarDeclRepeatDerived2(); :} /* empty */;

MethodDeclRepeat ::= MethodDeclRepeat:M1 MethodDecl:M2 {: RESULT=new MethodDeclRepeatDerived1(M1, M2); RESULT.setLine(M1left); :} | {: RESULT=new MethodDeclRepeatDerived2(); :} /* empty */;

MethodType ::= Type:T1 {: RESULT=new MethodTypeDerived1(T1); RESULT.setLine(T1left); :} | VOID {: RESULT=new MethodTypeDerived2(); :};
MethodDecl ::= MethodType:M1 IDENT:I2 LPAREN FormParsOptional:F3 RPAREN VarDeclRepeat:V4 LBRACE StatementRepeat:S5 RBRACE {: RESULT=new MethodDeclDerived1(M1, I2, F3, V4, S5); RESULT.setLine(M1left); :};

FormParsOptional ::= FormPars:F1 {: RESULT=new FormParsOptionalDerived1(F1); RESULT.setLine(F1left); :} | {: RESULT=new FormParsOptionalDerived2(); :} /* empty */;
FormParDecl ::= Type:T1 IDENT:I2 ArrayDeclOptional:A3 {: RESULT=new FormParDeclDerived1(T1, I2, A3); RESULT.setLine(T1left); :};
FormPars ::= FormParDecl:F1 FormParsRepeat:F2 {: RESULT=new FormParsDerived1(F1, F2); RESULT.setLine(F1left); :};
ArrayDeclOptional ::= LBRACKET RBRACKET {: RESULT=new ArrayDeclOptionalDerived1(); :} | {: RESULT=new ArrayDeclOptionalDerived2(); :} /* empty */;
FormParsRepeat ::= FormParsRepeat:F1 COMMA FormParDecl:F2 {: RESULT=new FormParsRepeatDerived1(F1, F2); RESULT.setLine(F1left); :} | {: RESULT=new FormParsRepeatDerived2(); :} /* empty */;

StatementRepeat ::= StatementRepeat:S1 Statement:S2 {: RESULT=new StatementRepeatDerived1(S1, S2); RESULT.setLine(S1left); :} | {: RESULT=new StatementRepeatDerived2(); :} /* empty */;
Statement ::= DesignatorStatement:D1 SEMICOLN {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
            |
            IF LPAREN Condition:C1 RPAREN Statement:S2 ElseStatementOptional:E3 {: RESULT=new StatementDerived2(C1, S2, E3); RESULT.setLine(C1left); :}
            |
            DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMICOLN {: RESULT=new StatementDerived3(S1, C2); RESULT.setLine(S1left); :}
            |
            SWITCH LPAREN Expr:E1 RPAREN LBRACE CaseRepeat:C2 RBRACE {: RESULT=new StatementDerived4(E1, C2); RESULT.setLine(E1left); :}
            |
            BREAK SEMICOLN {: RESULT=new StatementDerived5(); :}
            |
            CONTINUE SEMICOLN {: RESULT=new StatementDerived6(); :}
            |
            RETURN ExprOptional:E1 SEMICOLN {: RESULT=new StatementDerived7(E1); RESULT.setLine(E1left); :}
            |
            READ LPAREN Designator:D1 RPAREN SEMICOLN {: RESULT=new StatementDerived8(D1); RESULT.setLine(D1left); :}
            |
            PRINT LPAREN Expr:E1 PrintWidthOptional:P2 RPAREN SEMICOLN {: RESULT=new StatementDerived9(E1, P2); RESULT.setLine(E1left); :}
            |
            LBRACE StatementRepeat:S1 RBRACE {: RESULT=new StatementDerived10(S1); RESULT.setLine(S1left); :}
            ;

ElseStatementOptional ::= ELSE Statement:S1 {: RESULT=new ElseStatementOptionalDerived1(S1); RESULT.setLine(S1left); :};

PrintWidthOptional ::= COMMA NUM:N1 {: RESULT=new PrintWidthOptionalDerived1(N1); RESULT.setLine(N1left); :} | {: RESULT=new PrintWidthOptionalDerived2(); :} /* empty */;

CaseRepeat ::= CaseRepeat:C1 CASE NUM:N2 DDOTS StatementRepeat:S3 {: RESULT=new CaseRepeatDerived1(C1, N2, S3); RESULT.setLine(C1left); :} | {: RESULT=new CaseRepeatDerived2(); :} /* empty */;

DesignatorStatement ::= Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorStatementDerived1(D1, A2, E3); RESULT.setLine(D1left); :}
                      |
                      Designator:D1 LPAREN ActParsOptional:A2 RPAREN {: RESULT=new DesignatorStatementDerived2(D1, A2); RESULT.setLine(D1left); :}
                      |
                      Designator:D1 INC {: RESULT=new DesignatorStatementDerived3(D1); RESULT.setLine(D1left); :}
                      |
                      Designator:D1 DECR {: RESULT=new DesignatorStatementDerived4(D1); RESULT.setLine(D1left); :}
                      ;

Assignop ::= EQUAL {: RESULT=new AssignopDerived1(); :};
ActParsOptional ::= ActPars:A1 {: RESULT=new ActParsOptionalDerived1(A1); RESULT.setLine(A1left); :} | {: RESULT=new ActParsOptionalDerived2(); :} /* empty */;
ActPars ::= Expr:E1 ActParsExprRepeat:A2 {: RESULT=new ActParsDerived1(E1, A2); RESULT.setLine(E1left); :};
ActParsExprRepeat ::= ActParsExprRepeat:A1 COMMA Expr:E2 {: RESULT=new ActParsExprRepeatDerived1(A1, E2); RESULT.setLine(A1left); :};


Condition ::= CondTerm:C1 CondTermOrRepeat:C2 {: RESULT=new ConditionDerived1(C1, C2); RESULT.setLine(C1left); :};
CondTermOrRepeat ::= CondTermOrRepeat:C1 OR CondTerm:C2 {: RESULT=new CondTermOrRepeatDerived1(C1, C2); RESULT.setLine(C1left); :} | {: RESULT=new CondTermOrRepeatDerived2(); :} /* empty */;

CondTerm ::= CondFact:C1 CondFactorAndRepeat:C2 {: RESULT=new CondTermDerived1(C1, C2); RESULT.setLine(C1left); :};
CondFactorAndRepeat ::= CondFactorAndRepeat:C1 AND CondFact:C2 {: RESULT=new CondFactorAndRepeatDerived1(C1, C2); RESULT.setLine(C1left); :} | {: RESULT=new CondFactorAndRepeatDerived2(); :} /* empty */;
CondFact ::= Expr:E1 RelopExprOptional:R2 {: RESULT=new CondFactDerived1(E1, R2); RESULT.setLine(E1left); :};
RelopExprOptional ::= Relop:R1 Expr:E2 {: RESULT=new RelopExprOptionalDerived1(R1, E2); RESULT.setLine(R1left); :} | {: RESULT=new RelopExprOptionalDerived2(); :} /* empty */;
Relop ::= EQUALS {: RESULT=new RelopDerived1(); :} | NEQUALS {: RESULT=new RelopDerived2(); :} | GRT {: RESULT=new RelopDerived3(); :} | GRTEQUAL {: RESULT=new RelopDerived4(); :} | LESS {: RESULT=new RelopDerived5(); :} | LESSEQUAL {: RESULT=new RelopDerived6(); :};

ExprOptional ::= Expr:E1 {: RESULT=new ExprOptionalDerived1(E1); RESULT.setLine(E1left); :} | {: RESULT=new ExprOptionalDerived2(); :} /* empty */;

Expr::= MinusOptional:M1 Term:T2 TermAddopRepeat:T3 {: RESULT=new ExprDerived1(M1, T2, T3); RESULT.setLine(M1left); :};

MinusOptional ::= SUB {: RESULT=new MinusOptionalDerived1(); :} | {: RESULT=new MinusOptionalDerived2(); :} /* empty */;

TermAddopRepeat ::= TermAddopRepeat:T1 Addop:A2 Term:T3 {: RESULT=new TermAddopRepeatDerived1(T1, A2, T3); RESULT.setLine(T1left); :} | {: RESULT=new TermAddopRepeatDerived2(); :} /* empty */;

Term ::= Factor:F1 FactorMulopRepeat:F2 {: RESULT=new TermDerived1(F1, F2); RESULT.setLine(F1left); :};

FactorMulopRepeat ::= FactorMulopRepeat:F1 Mulop:M2 Factor:F3 {: RESULT=new FactorMulopRepeatDerived1(F1, M2, F3); RESULT.setLine(F1left); :}| {: RESULT=new FactorMulopRepeatDerived2(); :} /* empty */;

Factor ::= Designator:D1 {: RESULT=new FactorDerived1(D1); RESULT.setLine(D1left); :}
         |
         Designator:D1 LPAREN ActParsOptional:A2 RPAREN {: RESULT=new FactorDerived2(D1, A2); RESULT.setLine(D1left); :}
         |
         NUM:N1 {: RESULT=new FactorDerived3(N1); RESULT.setLine(N1left); :}
         |
         CHAR:C1 {: RESULT=new FactorDerived4(C1); RESULT.setLine(C1left); :}
         |
         BOOLEAN {: RESULT=new FactorDerived5(); :}
         |
         NEW Type:T1 LPAREN Expr:E2 RPAREN {: RESULT=new FactorDerived6(T1, E2); RESULT.setLine(T1left); :}
         |
         LPAREN Expr:E1 RPAREN {: RESULT=new FactorDerived7(E1); RESULT.setLine(E1left); :}
         ;


/*operators*/

Addop ::= ADD {: RESULT=new AddopDerived1(); :} | SUB {: RESULT=new AddopDerived2(); :};
Mulop ::= MUL {: RESULT=new MulopDerived1(); :} | DIV {: RESULT=new MulopDerived2(); :} | MOD {: RESULT=new MulopDerived3(); :};



Designator ::= IDENT:I1 {: RESULT=new DesignatorDerived1(I1); RESULT.setLine(I1left); :} | IDENT:I1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorDerived2(I1, E2); RESULT.setLine(I1left); :};
