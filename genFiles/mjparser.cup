package compiler;

import java_cup.runtime.*;
import org.apache.log4j.*;
import ast.*;



parser code {:
	boolean errorDetected = false;
	Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}
// preko yylex  
scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, RETURN, VOID, LBRACKET, RBRACKET, CLASS, EXTENDS;

terminal SEMICOLN, EQUAL, COMMA, DOT, LPAREN, RPAREN, LBRACE, RBRACE, CONST, NEW;
terminal PRINT,READ;

terminal ADD, SUB, MUL, DIV, MOD, INC, DECR;
terminal EQUALS, NEQUALS, GRT, GRTEQUAL, LESS, LESSEQUAL, AND, OR;

terminal IF, ELSE, SWITCH, CASE;
terminal DO, WHILE, BREAK, CONTINUE;

terminal DDOTS, QMARK;


//basetypes
//popraviti boolean?
terminal String IDENT;
terminal Integer NUM;
terminal Boolean BOOLEAN;
terminal Character CHAR;


non terminal Program, ConstVarClassDeclRepeat, ConstVarClassDecl;


non terminal ConstDecl, ConstDeclRepeat;
non terminal VarDecl, VarDeclIdentRepeat, ArrayBracketsDeclOptional, VarDeclRepeat;
non terminal ClassDecl, ClassExtendsOptional, ClassMethodDecl;
non terminal MethodDeclRepeat, MethodType, FormParsOptional, FormPars, FormParDecl, FormParRepeat;


non terminal StatementRepeat, Statement;
non terminal DesignatorStatement, SubDesignatorRepeat, ArrayBracketsOptional;

non terminal Assignment, Assignop, Mulop, Addop;
non terminal MinusOptional;
non terminal ActPars, ActParsOptional;

non terminal Condition, CondTermOrRepeat, CondTerm, CondFactorAndRepeat, CondFact, Relop, RelopExprOptional;

non terminal ElseStatementOptional, PrintWidthOptional, CaseRepeat;

non terminal SuperClass;


//===================


//SYNTAX NON TERMINAL
non terminal rs.etf.pp1.symboltable.concepts.Struct Type;

non terminal rs.etf.pp1.symboltable.concepts.Obj ProgramName;
non terminal rs.etf.pp1.symboltable.concepts.Obj ConstValue, MethodDecl, MethodTypeAndName;

non terminal rs.etf.pp1.symboltable.concepts.Obj Designator;
non terminal rs.etf.pp1.symboltable.concepts.Struct Factor,FactorMulopRepeat, Term,TermAddopRepeat, Expr, SmolExpr, FunctCall;


//===================

//PRECEDENCE
precedence left ELSE;



//terminali allcaps
//zagrade na desnoj strani su ime klase u ast
//PARSER
Program ::= (Program) PROGRAM ProgramName ConstVarClassDeclRepeat LBRACE MethodDeclRepeat RBRACE;
ProgramName ::= (ProgramName) IDENT:programName;

ConstVarClassDeclRepeat ::= (ConstVarClassDeclRepeatExists) ConstVarClassDeclRepeat ConstVarClassDecl
                        |
                        (ConstVarClassDeclRepeatEmpty) /* empty */
                        ;

ConstVarClassDecl ::= ConstDecl | VarDecl | ClassDecl;

Type ::= (Type) IDENT:typeName;

ConstDecl ::= (ConstDecl) CONST Type:Type IDENT:Name EQUAL ConstValue:Val ConstDeclRepeat SEMICOLN;
ConstValue ::= (ConstValueNum) NUM | (ConstValueChar) CHAR | (ConstValueBool) BOOLEAN;

ConstDeclRepeat ::= ConstDeclRepeat COMMA IDENT:Name EQUAL ConstValue:Val
                    |
                    /* empty */
                    ;


VarDecl ::= (VarDeclNoErr) Type:Type IDENT:Name ArrayBracketsDeclOptional VarDeclIdentRepeat SEMICOLN
            |
            error SEMICOLN
            ;

VarDeclIdentRepeat ::=  VarDeclIdentRepeat COMMA IDENT:Name ArrayBracketsDeclOptional 
                        |
                        error COMMA
                        |
                        /* empty */
                        ;


ArrayBracketsDeclOptional ::= (ArrayBracketsDeclExists) LBRACKET RBRACKET | /* empty */ (ArrayBracketsDeclEmpty);
VarDeclRepeat ::= VarDeclRepeat VarDecl | /* empty */;


ClassDecl ::= CLASS IDENT ClassExtendsOptional LBRACE VarDeclRepeat ClassMethodDecl RBRACE;
ClassExtendsOptional ::= (ClassExtendsExists) EXTENDS SuperClass | /* empty */ (ClassExtendsEmpty);
ClassMethodDecl ::= LBRACE MethodDeclRepeat RBRACE;

SuperClass::= IDENT | (ErrSuperClass) error;



MethodDecl ::= (MethodDecl) MethodTypeAndName LPAREN FormParsOptional RPAREN VarDeclRepeat LBRACE StatementRepeat RBRACE;
MethodDeclRepeat ::= MethodDeclRepeat MethodDecl | /* empty */;
MethodType ::= (MethodTypeReturn) Type | (MethodTypeReturnVoid) VOID;

MethodTypeAndName ::= (MethodTypeAndName) MethodType:retType IDENT:name;


//methodDeclPars != varDecl


FormParsOptional ::= (FormParsExists) FormPars | /* empty */;
FormPars ::= FormParDecl FormParRepeat;

FormParDecl ::= (MethodLocalVar) Type:Type IDENT:Name ArrayBracketsDeclOptional
                |
                error
                ;


FormParRepeat ::= FormParRepeat COMMA FormParDecl 
                    |
                    error COMMA
                    |
                    /* empty */
                    ;


StatementRepeat ::= StatementRepeat Statement | /* empty */;
Statement ::= DesignatorStatement SEMICOLN
            |
            (IfStatement) IF LPAREN Condition RPAREN Statement ElseStatementOptional
            |
            (DoWhileStatement) DO Statement WHILE LPAREN Condition RPAREN SEMICOLN
            |
            (SwitchStatement) SWITCH LPAREN Expr RPAREN LBRACE CaseRepeat RBRACE
            |
            (BreakStatement) BREAK SEMICOLN
            |
            (ContinueStatement) CONTINUE SEMICOLN
            |
            (ReturnExprStatement) RETURN Expr SEMICOLN
            |
            (ReturnNoExprStatement) RETURN SEMICOLN
            |
            (ReadStatement) READ LPAREN Designator RPAREN SEMICOLN
            |
            (PrintStatement) PRINT LPAREN Expr PrintWidthOptional RPAREN SEMICOLN
            |
            (CodeBlockStatement) LBRACE StatementRepeat RBRACE
            ;


DesignatorStatement ::= Assignment
                        |
                        FunctCall
                        |
                        Designator INC
                        |
                        Designator DECR
                        ;

Assignment ::= (AssignmentNoErr) Designator:Designator Assignop Expr:Expr
                |
                error
                ;

Designator ::= (Designator) IDENT:Name ArrayBracketsOptional SubDesignatorRepeat;
SubDesignatorRepeat ::= (SubDesignatorRepeatExists) SubDesignatorRepeat DOT IDENT:Name ArrayBracketsOptional | /* empty */;
ArrayBracketsOptional ::= (ArrayBracketsExists) LBRACKET Expr:Index RBRACKET |(ArrayBracketsEmpty) /* empty */ ;

/*operators*/
Assignop ::= EQUAL;
Mulop ::= MUL | DIV | MOD;
Addop ::= ADD | SUB;


MinusOptional ::= (MinusExists) SUB | (MinusEmpty) /* empty */;



//TERNARNI old code
//Expr::= MinusOptional Term:Term TermAddopRepeat;


//new ziza ternarni
Expr ::= (TernaryOperatorExpr) SmolExpr:TernConditionExpr QMARK SmolExpr:Truthy DDOTS SmolExpr:Falsey
        |
        (NoTernExpr) SmolExpr:SmolExpr
        ;

SmolExpr ::=  (SmolExpr) MinusOptional Term:Term TermAddopRepeat:OtherTerms;


TermAddopRepeat ::= (TermAddopRepeatExists) TermAddopRepeat:OtherTerms Addop Term | (TermAddopRepeatEmpty) /* empty */;
Term ::= (Term) Factor:Factor FactorMulopRepeat:OtherFactors;
FactorMulopRepeat ::= (FactorMulopRepeatExists) FactorMulopRepeat:OtherFactors Mulop Factor:Factor | (FactorMulopRepeatEmpty) /* empty */;

Factor ::=  (DesFactor) Designator:Designator
            |
            (FunctCallFactor) FunctCall:FunctCall
            |
            (ConstFactor) ConstValue:ConstValue
            |
            (NewOperatorFactor) NEW Type:Type ArrayBracketsOptional
            |
            (SubExprFactor) LPAREN Expr RPAREN
            ;


FunctCall ::= (FunctCall) Designator:func LPAREN ActParsOptional:Params RPAREN;

ActParsOptional ::= (ActParsExists) ActPars | (ActParsEmpty) /* empty */;
ActPars ::= (ActParsMultiple) ActPars COMMA Expr:Expr | (ActParsSingle) Expr:Expr;


Condition ::= CondTerm CondTermOrRepeat | (ErrCondition) error;
CondTermOrRepeat ::= CondTermOrRepeat OR CondTerm | /* empty */;

CondTerm ::= CondFact CondFactorAndRepeat;
CondFactorAndRepeat ::= CondFactorAndRepeat AND CondFact | /* empty */;
CondFact ::= Expr RelopExprOptional;

Relop ::= EQUALS | NEQUALS | GRT | GRTEQUAL | LESS | LESSEQUAL;
RelopExprOptional ::= (RelopExprExists) Relop Expr |(RelopExprEmpty) /* empty */;


ElseStatementOptional ::= (ElseStatementExists) ELSE Statement | (ElseStatementEmpty) /* empty */;
CaseRepeat ::= CaseRepeat CASE NUM DDOTS StatementRepeat | /* empty */;
PrintWidthOptional ::= (PrintWidthExists) COMMA NUM | (PrintWidthEmpty) /* empty */;






