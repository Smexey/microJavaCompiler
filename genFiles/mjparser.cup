package compiler;

import java_cup.runtime.*;
import org.apache.log4j.*;
import ast.*;



parser code {:
	boolean errorDetected = false;
	Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}
// preko yylex  
scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, RETURN, VOID, LBRACKET, RBRACKET, CLASS, EXTENDS;

terminal SEMICOLN, EQUAL, COMMA, DOT, LPAREN, RPAREN, LBRACE, RBRACE, CONST, NEW;
terminal PRINT,READ;

terminal ADD, SUB, MUL, DIV, MOD, INC, DECR;
terminal EQUALS, NEQUALS, GRT, GRTEQUAL, LESS, LESSEQUAL, AND, OR;

terminal IF, ELSE, SWITCH, CASE;
terminal DO, WHILE, BREAK, CONTINUE;

terminal DDOTS, QMARK;


//basetypes
//popraviti boolean?
terminal String IDENT;
terminal Integer NUM;
terminal Object BOOLEAN;
terminal Character CHAR;


non terminal Program, ConstVarClassDeclRepeat, ConstVarClassDecl;

non terminal Type;
non terminal ConstDecl, ConstValue, ConstDeclRepeat;
non terminal VarDecl, VarDeclIdentRepeat, ArrayBracketsDeclOptional, VarDeclRepeat;
non terminal ClassDecl, ClassExtendsOptional, ClassMethodDecl;
non terminal MethodDecl, MethodDeclRepeat, MethodType, FormParsOptional, FormPars, FormParDecl, FormParRepeat;


non terminal FunctCall;
non terminal StatementRepeat, Statement;
non terminal DesignatorStatement, Designator, SubDesignatorRepeat, ArrayBracketsOptional;

non terminal Assignop, Mulop, Addop;
non terminal MinusOptional, ExprOptional, Expr;
non terminal TermAddopRepeat, Term, Factor, FactorMulopRepeat, ActPars, ActParsOptional;

non terminal Condition, CondTermOrRepeat, CondTerm, CondFactorAndRepeat, CondFact, Relop, RelopExprOptional;

non terminal ElseStatementOptional, PrintWidthOptional, CaseRepeat;



precedence left ELSE;

//terminali allcaps
//zagrade na desnoj strani su ime klase u ast


Program ::= (Program) PROGRAM IDENT:programName ConstVarClassDeclRepeat LBRACE MethodDeclRepeat RBRACE;

ConstVarClassDeclRepeat ::= (ConstVarClassDeclRepeatExists) ConstVarClassDeclRepeat ConstVarClassDecl
                        |
                        (ConstVarClassDeclRepeatEmpty) /* empty */
                        ;

ConstVarClassDecl ::= ConstDecl | VarDecl | ClassDecl;

Type ::= IDENT:typeName;

ConstDecl ::= CONST Type IDENT EQUAL ConstValue ConstDeclRepeat SEMICOLN;
ConstValue ::= NUM | CHAR | BOOLEAN;
ConstDeclRepeat ::= ConstDeclRepeat COMMA IDENT EQUAL ConstValue | /* empty */;


VarDecl ::= Type IDENT ArrayBracketsDeclOptional VarDeclIdentRepeat SEMICOLN;
VarDeclIdentRepeat ::= VarDeclIdentRepeat COMMA IDENT ArrayBracketsDeclOptional | /* empty */;
ArrayBracketsDeclOptional ::= (ArrayBracketsDeclExists) LBRACKET RBRACKET | /* empty */ (ArrayBracketsDeclEmpty);
VarDeclRepeat ::= VarDeclRepeat VarDecl | /* empty */;


ClassDecl ::= CLASS IDENT ClassExtendsOptional LBRACE VarDeclRepeat ClassMethodDecl RBRACE;
ClassExtendsOptional ::= (ClassExtendsExists) EXTENDS IDENT | /* empty */ (ClassExtendsEmpty);
ClassMethodDecl ::= LBRACE MethodDeclRepeat RBRACE;


MethodDecl ::= MethodType IDENT LPAREN FormParsOptional RPAREN VarDeclRepeat LBRACE StatementRepeat RBRACE;
MethodDeclRepeat ::= MethodDeclRepeat MethodDecl | /* empty */;
MethodType ::= (MethodTypeReturn) Type | (MethodTypeReturnVoid) VOID;


//methodDeclPars != varDecl
FormParsOptional ::= FormPars | /* empty */;
FormPars ::= FormParDecl FormParRepeat;
FormParDecl ::= Type IDENT ArrayBracketsDeclOptional;
FormParRepeat ::= FormParRepeat COMMA FormParDecl | /* empty */;


StatementRepeat ::= StatementRepeat Statement | /* empty */;
Statement ::= DesignatorStatement SEMICOLN
            |
            IF LPAREN Condition RPAREN Statement ElseStatementOptional
            |
            DO Statement WHILE LPAREN Condition RPAREN SEMICOLN
            |
            SWITCH LPAREN Expr RPAREN LBRACE CaseRepeat RBRACE
            |
            BREAK SEMICOLN
            |
            CONTINUE SEMICOLN
            |
            RETURN ExprOptional SEMICOLN
            |
            READ LPAREN Designator RPAREN SEMICOLN
            |
            PRINT LPAREN Expr PrintWidthOptional RPAREN SEMICOLN
            |
            LBRACE StatementRepeat RBRACE
            ;


DesignatorStatement ::= Designator Assignop Expr
                        |
                        FunctCall
                        |
                        Designator INC
                        |
                        Designator DECR
                        ;


Designator ::= IDENT ArrayBracketsOptional SubDesignatorRepeat;
SubDesignatorRepeat ::= SubDesignatorRepeat DOT IDENT ArrayBracketsOptional | /* empty */;
ArrayBracketsOptional ::= (ArrayBracketsExists) LBRACKET Expr RBRACKET |(ArrayBracketsEmpty) /* empty */ ;

/*operators*/
Assignop ::= EQUAL;
Mulop ::= MUL | DIV | MOD;
Addop ::= ADD | SUB;



MinusOptional ::= (MinusExists) SUB | (MinusEmpty) /* empty */;


//TODO: TERNARNI 
ExprOptional ::= (ExprExists) Expr | (ExprEmpty) /* empty */;
Expr::= MinusOptional Term TermAddopRepeat;

TermAddopRepeat ::= TermAddopRepeat Addop Term | /* empty */;
Term ::= Factor FactorMulopRepeat;
FactorMulopRepeat ::= FactorMulopRepeat Mulop Factor| /* empty */;

Factor ::= Designator
            |
            FunctCall
            |
            NUM
            |
            CHAR
            |
            BOOLEAN
            |
            NEW Type:typeName ArrayBracketsOptional
            |
            LPAREN Expr RPAREN
            ;


FunctCall ::= Designator:func LPAREN ActParsOptional:param RPAREN;

ActParsOptional ::= (ActParsExists) ActPars | (ActParsEmpty) /* empty */;
ActPars ::= ActPars COMMA Expr | Expr;


Condition ::= CondTerm CondTermOrRepeat;
CondTermOrRepeat ::= CondTermOrRepeat OR CondTerm | /* empty */;

CondTerm ::= CondFact CondFactorAndRepeat;
CondFactorAndRepeat ::= CondFactorAndRepeat AND CondFact | /* empty */;
CondFact ::= Expr RelopExprOptional;

Relop ::= EQUALS | NEQUALS | GRT | GRTEQUAL | LESS | LESSEQUAL;
RelopExprOptional ::= (RelopExprExists) Relop Expr |(RelopExprEmpty) /* empty */;


ElseStatementOptional ::= (ElseStatementExists) ELSE Statement | (ElseStatementEmpty) /* empty */;
CaseRepeat ::= CaseRepeat CASE NUM DDOTS StatementRepeat | /* empty */;
PrintWidthOptional ::= (PrintWidthExists) COMMA NUM | (PrintWidthEmpty) /* empty */;

